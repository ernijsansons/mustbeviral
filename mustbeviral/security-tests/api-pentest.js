/**
 * Security Penetration Testing - API Endpoints
 * Tests for API security vulnerabilities and misconfigurations
 */

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Counter } from 'k6/metrics';

// Custom metrics for API security testing
const vulnerabilityDetected = new Rate('api_vulnerabilities_detected');
const securityTestsPassed = new Rate('api_security_tests_passed');
const unauthorizedAccess = new Counter('unauthorized_access_attempts');
const rateLimitBypass = new Counter('rate_limit_bypass_attempts');

export const options = {
  scenarios: {
    api_security_scan: {
      executor: 'constant-vus',
      vus: 3,
      duration: '8m',
    },
  },
  thresholds: {
    api_vulnerabilities_detected: ['rate<0.05'],
    api_security_tests_passed: ['rate>0.95'],
  },
};

const BASE_URL = __ENV.BASE_URL || 'http://localhost:5173';
const API_BASE_URL = __ENV.API_BASE_URL || 'http://localhost:8787';

// API endpoints to test
const apiEndpoints = [
  { method: 'GET', path: '/api/content', requiresAuth: true },
  { method: 'POST', path: '/api/content', requiresAuth: true },
  { method: 'GET', path: '/api/boost', requiresAuth: true },
  { method: 'POST', path: '/api/boost', requiresAuth: true },
  { method: 'GET', path: '/api/earnings', requiresAuth: true },
  { method: 'GET', path: '/api/payments', requiresAuth: true },
  { method: 'POST', path: '/api/payments/intent', requiresAuth: true },
  { method: 'GET', path: '/api/auth/profile', requiresAuth: true },
  { method: 'POST', path: '/api/auth/login', requiresAuth: false },
  { method: 'POST', path: '/api/auth/register', requiresAuth: false },
];

// Malicious payloads for various attacks
const payloads = {
  nosql_injection: [
    '{"$gt":""}',
    '{"$ne":null}',
    '{"$regex":".*"}',
    '{"$where":"this.password"}',
  ],
  xxe: [
    '<?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&xxe;</foo>',
    '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY file SYSTEM "file:///c:/windows/win.ini">]><data>&file;</data>',
  ],
  deserialization: [
    'O:8:"stdClass":1:{s:4:"test";s:4:"evil";}',
    'rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABdAABYXQAAWJ4',
  ],
  ldap_injection: [
    '*)(uid=*))(|(uid=*',
    '*)(|(password=*))',
    '*)(&(objectClass=*)',
  ],
};

let validAuthToken = null;

export function setup() {
  console.log('üöÄ Starting API security test setup...');

  // Create a test user and get valid auth token
  const testUser = {
    email: 'apisecurity@mustbeviral.com',
    username: 'apisecurityuser',
    password: 'APISecurityTest123!',
    role: 'creator'
  };

  // Register user
  const registerResponse = http.post(
    `${API_BASE_URL}/api/auth/register`,
    JSON.stringify(testUser),
    { headers: { 'Content-Type': 'application/json' } }
  );

  // Login to get token
  const loginResponse = http.post(
    `${API_BASE_URL}/api/auth/login`,
    JSON.stringify({
      email: testUser.email,
      password: testUser.password
    }),
    { headers: { 'Content-Type': 'application/json' } }
  );

  if (loginResponse.status === 200) {
    try {
      const loginData = JSON.parse(loginResponse.body);
      validAuthToken = loginData.token;
    } catch (e) {
      console.log('Failed to parse login response');
    }
  }

  console.log('‚úÖ API security test setup completed');
  return { validAuthToken };
}

export default function (data) {
  const testType = Math.random();

  if (testType < 0.3) {
    testUnauthorizedAccess(data.validAuthToken);
  } else if (testType < 0.5) {
    testInputValidation(data.validAuthToken);
  } else if (testType < 0.7) {
    testRateLimiting(data.validAuthToken);
  } else {
    testAPIAbuse(data.validAuthToken);
  }

  sleep(1);
}

function testUnauthorizedAccess(validToken) {
  console.log('üõ°Ô∏è Testing unauthorized access to protected endpoints...');

  for (const endpoint of apiEndpoints.filter(ep => ep.requiresAuth)) {
    // Test 1: No authorization header
    const noAuthResponse = http.request(endpoint.method, `${API_BASE_URL}${endpoint.path}`, null, {
      tags: { security_test: 'unauthorized_access', endpoint: endpoint.path, method: 'no_auth' },
    });

    const noAuthBlocked = check(noAuthResponse, {
      [`${endpoint.path} blocks requests without auth`]: (r) => r.status === 401
    });

    if (!noAuthBlocked) {
      vulnerabilityDetected.add(1);
      unauthorizedAccess.add(1);
      console.log(`‚ö†Ô∏è Unauthorized access allowed to ${endpoint.path} without authentication`);
    } else {
      securityTestsPassed.add(1);
    }

    // Test 2: Invalid token
    const invalidTokenResponse = http.request(endpoint.method, `${API_BASE_URL}${endpoint.path}`, null, {
      headers: { 'Authorization': 'Bearer invalid-token' },
      tags: { security_test: 'unauthorized_access', endpoint: endpoint.path, method: 'invalid_token' },
    });

    const invalidTokenBlocked = check(invalidTokenResponse, {
      [`${endpoint.path} blocks requests with invalid token`]: (r) => r.status === 401
    });

    if (!invalidTokenBlocked) {
      vulnerabilityDetected.add(1);
      unauthorizedAccess.add(1);
      console.log(`‚ö†Ô∏è Invalid token accepted for ${endpoint.path}`);
    } else {
      securityTestsPassed.add(1);
    }

    // Test 3: Expired token (simulate)
    const expiredToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjJ9.4Adz3hmm78oqTIC8mWYoWfuW7g4fawYXDfMn9oKn3xU';

    const expiredTokenResponse = http.request(endpoint.method, `${API_BASE_URL}${endpoint.path}`, null, {
      headers: { 'Authorization': `Bearer ${expiredToken}` },
      tags: { security_test: 'unauthorized_access', endpoint: endpoint.path, method: 'expired_token' },
    });

    const expiredTokenBlocked = check(expiredTokenResponse, {
      [`${endpoint.path} blocks expired tokens`]: (r) => r.status === 401
    });

    if (!expiredTokenBlocked) {
      vulnerabilityDetected.add(1);
      unauthorizedAccess.add(1);
      console.log(`‚ö†Ô∏è Expired token accepted for ${endpoint.path}`);
    } else {
      securityTestsPassed.add(1);
    }
  }
}

function testInputValidation(validToken) {
  console.log('üõ°Ô∏è Testing input validation vulnerabilities...');

  const headers = validToken ? {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${validToken}`
  } : { 'Content-Type': 'application/json' };

  // Test NoSQL injection on content creation
  for (const payload of payloads.nosql_injection) {
    const maliciousContent = {
      title: payload,
      description: 'Test content',
      type: 'video',
      url: 'https://example.com/test.mp4'
    };

    const response = http.post(
      `${API_BASE_URL}/api/content`,
      JSON.stringify(maliciousContent),
      {
        headers,
        tags: { security_test: 'input_validation', attack: 'nosql_injection' },
      }
    );

    const nosqlBlocked = check(response, {
      'NoSQL injection blocked in content creation': (r) => {
        return r.status === 400 || (r.status === 200 && !r.body.includes('$gt'));
      }
    });

    if (!nosqlBlocked) {
      vulnerabilityDetected.add(1);
      console.log(`‚ö†Ô∏è Potential NoSQL injection vulnerability with payload: ${payload}`);
    } else {
      securityTestsPassed.add(1);
    }
  }

  // Test XXE on registration (if XML is processed)
  for (const xxePayload of payloads.xxe) {
    const response = http.post(
      `${API_BASE_URL}/api/auth/register`,
      xxePayload,
      {
        headers: { 'Content-Type': 'application/xml' },
        tags: { security_test: 'input_validation', attack: 'xxe' },
      }
    );

    const xxeBlocked = check(response, {
      'XXE attack blocked': (r) => {
        return !r.body.includes('root:') && !r.body.includes('[boot loader]');
      }
    });

    if (!xxeBlocked) {
      vulnerabilityDetected.add(1);
      console.log(`‚ö†Ô∏è Potential XXE vulnerability detected`);
    } else {
      securityTestsPassed.add(1);
    }
  }

  // Test oversized payloads
  const oversizedData = {
    title: 'A'.repeat(10000),
    description: 'B'.repeat(50000),
    type: 'video',
    url: 'https://example.com/test.mp4'
  };

  const oversizedResponse = http.post(
    `${API_BASE_URL}/api/content`,
    JSON.stringify(oversizedData),
    {
      headers,
      tags: { security_test: 'input_validation', attack: 'oversized_payload' },
    }
  );

  const oversizedBlocked = check(oversizedResponse, {
    'oversized payload rejected': (r) => r.status === 400 || r.status === 413
  });

  if (!oversizedBlocked) {
    vulnerabilityDetected.add(1);
    console.log(`‚ö†Ô∏è Oversized payloads not properly handled`);
  } else {
    securityTestsPassed.add(1);
  }
}

function testRateLimiting(validToken) {
  console.log('üõ°Ô∏è Testing rate limiting vulnerabilities...');

  const headers = validToken ? {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${validToken}`
  } : { 'Content-Type': 'application/json' };

  // Test rapid requests to login endpoint
  const loginAttempts = 10;
  let blockedRequests = 0;

  for (let i = 0; i < loginAttempts; i++) {
    const response = http.post(
      `${API_BASE_URL}/api/auth/login`,
      JSON.stringify({
        email: 'brute@force.com',
        password: 'wrongpassword'
      }),
      {
        headers: { 'Content-Type': 'application/json' },
        tags: { security_test: 'rate_limiting', attack: 'brute_force' },
      }
    );

    if (response.status === 429) {
      blockedRequests++;
    }
  }

  const rateLimitWorking = check({ blockedRequests }, {
    'rate limiting active for login attempts': (data) => data.blockedRequests > 0
  });

  if (!rateLimitWorking) {
    vulnerabilityDetected.add(1);
    rateLimitBypass.add(1);
    console.log(`‚ö†Ô∏è No rate limiting detected on login endpoint`);
  } else {
    securityTestsPassed.add(1);
  }

  // Test rapid API calls
  const apiAttempts = 20;
  let apiBlocked = 0;

  for (let i = 0; i < apiAttempts; i++) {
    const response = http.get(
      `${API_BASE_URL}/api/content`,
      {
        headers,
        tags: { security_test: 'rate_limiting', attack: 'api_flooding' },
      }
    );

    if (response.status === 429) {
      apiBlocked++;
    }
  }

  const apiRateLimitWorking = check({ apiBlocked }, {
    'rate limiting active for API calls': (data) => data.apiBlocked > 0
  });

  if (!apiRateLimitWorking) {
    vulnerabilityDetected.add(1);
    rateLimitBypass.add(1);
    console.log(`‚ö†Ô∏è No rate limiting detected on API endpoints`);
  } else {
    securityTestsPassed.add(1);
  }
}

function testAPIAbuse(validToken) {
  console.log('üõ°Ô∏è Testing API abuse vulnerabilities...');

  const headers = validToken ? {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${validToken}`
  } : { 'Content-Type': 'application/json' };

  // Test parameter pollution
  const pollutedResponse = http.get(
    `${API_BASE_URL}/api/content?page=1&page=999&limit=10&limit=999999`,
    {
      headers,
      tags: { security_test: 'api_abuse', attack: 'parameter_pollution' },
    }
  );

  const pollutionHandled = check(pollutedResponse, {
    'parameter pollution handled correctly': (r) => {
      // Should not return massive datasets or cause errors
      return r.status !== 500 && r.timings.duration < 5000;
    }
  });

  if (!pollutionHandled) {
    vulnerabilityDetected.add(1);
    console.log(`‚ö†Ô∏è Parameter pollution vulnerability detected`);
  } else {
    securityTestsPassed.add(1);
  }

  // Test HTTP method manipulation
  const methodTests = ['PATCH', 'PUT', 'DELETE', 'HEAD', 'OPTIONS', 'TRACE'];

  for (const method of methodTests) {
    const response = http.request(method, `${API_BASE_URL}/api/content`, null, {
      headers,
      tags: { security_test: 'api_abuse', attack: 'method_manipulation', method },
    });

    // Should return 405 Method Not Allowed for unsupported methods
    const methodBlocked = check(response, {
      [`${method} method properly handled`]: (r) => r.status === 405 || r.status === 404 || r.status === 200
    });

    if (!methodBlocked && response.status === 500) {
      vulnerabilityDetected.add(1);
      console.log(`‚ö†Ô∏è HTTP method ${method} causes server error`);
    } else {
      securityTestsPassed.add(1);
    }
  }

  // Test directory traversal in API paths
  const traversalPaths = [
    '/api/../etc/passwd',
    '/api/content/../../admin',
    '/api/content/%2e%2e%2f%2e%2e%2fpasswd',
  ];

  for (const path of traversalPaths) {
    const response = http.get(`${API_BASE_URL}${path}`, {
      headers,
      tags: { security_test: 'api_abuse', attack: 'path_traversal' },
    });

    const traversalBlocked = check(response, {
      'path traversal blocked': (r) => {
        return !r.body.includes('root:') && !r.body.includes('administrator') && r.status !== 200;
      }
    });

    if (!traversalBlocked) {
      vulnerabilityDetected.add(1);
      console.log(`‚ö†Ô∏è Path traversal vulnerability with path: ${path}`);
    } else {
      securityTestsPassed.add(1);
    }
  }
}

export function handleSummary(data) {
  return {
    'api-pentest-results.json': JSON.stringify(data, null, 2),
    stdout: `
üõ°Ô∏è API Security Test Results
============================

üîç API Security Metrics:
- Total API Security Tests: ${data.metrics.http_reqs.values.count}
- Vulnerabilities Detected: ${(data.metrics.api_vulnerabilities_detected?.values.rate * 100 || 0).toFixed(2)}%
- Security Tests Passed: ${(data.metrics.api_security_tests_passed?.values.rate * 100 || 0).toFixed(2)}%
- Unauthorized Access Attempts: ${data.metrics.unauthorized_access_attempts?.values.count || 0}
- Rate Limit Bypass Attempts: ${data.metrics.rate_limit_bypass_attempts?.values.count || 0}

üéØ API Security Assessment:
${(data.metrics.api_vulnerabilities_detected?.values.rate || 0) < 0.05 ? '‚úÖ SECURE - API endpoints properly protected' : ''}
${(data.metrics.api_vulnerabilities_detected?.values.rate || 0) >= 0.05 && (data.metrics.api_vulnerabilities_detected?.values.rate || 0) < 0.2 ? '‚ö†Ô∏è MODERATE RISK - Some API vulnerabilities detected' : ''}
${(data.metrics.api_vulnerabilities_detected?.values.rate || 0) >= 0.2 ? 'üö® HIGH RISK - Multiple API vulnerabilities detected' : ''}

üîß Security Recommendations:
- Implement proper authentication on all protected endpoints
- Add input validation and sanitization
- Configure rate limiting on all API endpoints
- Implement proper error handling
- Add API request logging and monitoring
- Use HTTPS for all API communications
- Implement API versioning strategy

üéØ Threshold Results:
${Object.entries(data.thresholds || {}).map(([key, result]) =>
  `- ${key}: ${result.ok ? '‚úÖ PASS' : '‚ùå FAIL'}`
).join('\n')}
`,
  };
}