/**
 * Security Penetration Testing - Authentication
 * Tests for authentication vulnerabilities and security weaknesses
 */

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

// Custom metrics for security testing
const vulnerabilityDetected = new Rate('vulnerabilities_detected');
const securityTestsPassed = new Rate('security_tests_passed');

export const options = {
  scenarios: {
    auth_security_scan: {
      executor: 'constant-vus',
      vus: 5,
      duration: '5m',
    },
  },
  thresholds: {
    vulnerabilities_detected: ['rate<0.1'], // Less than 10% of tests should detect vulnerabilities
    security_tests_passed: ['rate>0.9'],   // More than 90% of security tests should pass
  },
};

const BASE_URL = __ENV.BASE_URL || 'http://localhost:5173';
const API_BASE_URL = __ENV.API_BASE_URL || 'http://localhost:8787';

// Common attack payloads
const sqlInjectionPayloads = [
  "' OR '1'='1",
  "' OR 1=1--",
  "' UNION SELECT * FROM users--",
  "admin'--",
  "' OR 'x'='x",
  "1' OR '1'='1' /*",
];

const xssPayloads = [
  "<script>alert('XSS')</script>",
  "javascript:alert('XSS')",
  "<img src=x onerror=alert('XSS')>",
  "';alert('XSS');//",
  "<svg onload=alert('XSS')>",
];

const commandInjectionPayloads = [
  "; ls -la",
  "| whoami",
  "; cat /etc/passwd",
  "&& dir",
  "; ping google.com",
];

const pathTraversalPayloads = [
  "../../../etc/passwd",
  "....//....//....//etc/passwd",
  "..%2F..%2F..%2Fetc%2Fpasswd",
  "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
];

export default function () {
  const testType = Math.random();

  if (testType < 0.25) {
    testSQLInjection();
  } else if (testType < 0.5) {
    testXSSVulnerabilities();
  } else if (testType < 0.75) {
    testAuthenticationBypass();
  } else {
    testSessionManagement();
  }

  sleep(1);
}

function testSQLInjection() {
  console.log('üõ°Ô∏è Testing SQL Injection vulnerabilities...');

  for (const payload of sqlInjectionPayloads) {
    // Test login endpoint
    const loginData = {
      email: payload,
      password: 'testpassword'
    };

    const loginResponse = http.post(
      `${API_BASE_URL}/api/auth/login`,
      JSON.stringify(loginData),
      {
        headers: { 'Content-Type': 'application/json' },
        tags: { security_test: 'sql_injection', target: 'login' },
      }
    );

    const loginVulnerable = check(loginResponse, {
      'login SQL injection blocked': (r) => {
        // If we get a 200 response or unusual behavior, it might be vulnerable
        return r.status !== 200 && !r.body.includes('syntax error') && !r.body.includes('users');
      }
    });

    if (!loginVulnerable) {
      vulnerabilityDetected.add(1);
      console.log(`‚ö†Ô∏è Potential SQL injection vulnerability in login with payload: ${payload}`);
    } else {
      securityTestsPassed.add(1);
    }

    // Test registration endpoint
    const regData = {
      email: payload,
      username: 'testuser',
      password: 'testpassword',
      role: 'creator'
    };

    const regResponse = http.post(
      `${API_BASE_URL}/api/auth/register`,
      JSON.stringify(regData),
      {
        headers: { 'Content-Type': 'application/json' },
        tags: { security_test: 'sql_injection', target: 'register' },
      }
    );

    const regVulnerable = check(regResponse, {
      'register SQL injection blocked': (r) => {
        return r.status !== 200 && !r.body.includes('syntax error') && !r.body.includes('users');
      }
    });

    if (!regVulnerable) {
      vulnerabilityDetected.add(1);
      console.log(`‚ö†Ô∏è Potential SQL injection vulnerability in registration with payload: ${payload}`);
    } else {
      securityTestsPassed.add(1);
    }
  }
}

function testXSSVulnerabilities() {
  console.log('üõ°Ô∏è Testing XSS vulnerabilities...');

  for (const payload of xssPayloads) {
    // Test user registration with XSS in username
    const userData = {
      email: 'xsstest@example.com',
      username: payload,
      password: 'testpassword',
      role: 'creator'
    };

    const response = http.post(
      `${API_BASE_URL}/api/auth/register`,
      JSON.stringify(userData),
      {
        headers: { 'Content-Type': 'application/json' },
        tags: { security_test: 'xss', target: 'username' },
      }
    );

    const xssBlocked = check(response, {
      'XSS payload in username blocked': (r) => {
        // Check if the payload is properly escaped or blocked
        return !r.body.includes('<script>') && !r.body.includes('alert(') && !r.body.includes('javascript:');
      }
    });

    if (!xssBlocked) {
      vulnerabilityDetected.add(1);
      console.log(`‚ö†Ô∏è Potential XSS vulnerability in username with payload: ${payload}`);
    } else {
      securityTestsPassed.add(1);
    }

    // Test XSS in email field
    const emailXSSData = {
      email: payload,
      username: 'testuser',
      password: 'testpassword',
      role: 'creator'
    };

    const emailResponse = http.post(
      `${API_BASE_URL}/api/auth/register`,
      JSON.stringify(emailXSSData),
      {
        headers: { 'Content-Type': 'application/json' },
        tags: { security_test: 'xss', target: 'email' },
      }
    );

    const emailXSSBlocked = check(emailResponse, {
      'XSS payload in email blocked': (r) => {
        return !r.body.includes('<script>') && !r.body.includes('alert(') && !r.body.includes('javascript:');
      }
    });

    if (!emailXSSBlocked) {
      vulnerabilityDetected.add(1);
      console.log(`‚ö†Ô∏è Potential XSS vulnerability in email with payload: ${payload}`);
    } else {
      securityTestsPassed.add(1);
    }
  }
}

function testAuthenticationBypass() {
  console.log('üõ°Ô∏è Testing authentication bypass vulnerabilities...');

  // Test 1: JWT Token Manipulation
  const fakeTokens = [
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c',
    'null',
    'admin',
    '',
    'Bearer fake-token',
  ];

  for (const fakeToken of fakeTokens) {
    const response = http.get(
      `${API_BASE_URL}/api/auth/profile`,
      {
        headers: { 'Authorization': `Bearer ${fakeToken}` },
        tags: { security_test: 'auth_bypass', method: 'fake_token' },
      }
    );

    const bypassBlocked = check(response, {
      'fake token rejected': (r) => r.status === 401 || r.status === 403
    });

    if (!bypassBlocked) {
      vulnerabilityDetected.add(1);
      console.log(`‚ö†Ô∏è Authentication bypass vulnerability with fake token: ${fakeToken}`);
    } else {
      securityTestsPassed.add(1);
    }
  }

  // Test 2: Missing Authorization Header
  const noAuthResponse = http.get(
    `${API_BASE_URL}/api/auth/profile`,
    {
      tags: { security_test: 'auth_bypass', method: 'no_auth' },
    }
  );

  const noAuthBlocked = check(noAuthResponse, {
    'missing authorization rejected': (r) => r.status === 401
  });

  if (!noAuthBlocked) {
    vulnerabilityDetected.add(1);
    console.log(`‚ö†Ô∏è Missing authorization not properly handled`);
  } else {
    securityTestsPassed.add(1);
  }

  // Test 3: Malformed Authorization Headers
  const malformedHeaders = [
    'Bearer',
    'Basic admin:admin',
    'Token fake-token',
    'JWT fake-token',
  ];

  for (const header of malformedHeaders) {
    const response = http.get(
      `${API_BASE_URL}/api/auth/profile`,
      {
        headers: { 'Authorization': header },
        tags: { security_test: 'auth_bypass', method: 'malformed_header' },
      }
    );

    const malformedBlocked = check(response, {
      'malformed auth header rejected': (r) => r.status === 401 || r.status === 400
    });

    if (!malformedBlocked) {
      vulnerabilityDetected.add(1);
      console.log(`‚ö†Ô∏è Malformed authorization header accepted: ${header}`);
    } else {
      securityTestsPassed.add(1);
    }
  }
}

function testSessionManagement() {
  console.log('üõ°Ô∏è Testing session management vulnerabilities...');

  // Test 1: Session Fixation
  const validCredentials = {
    email: 'test@example.com',
    password: 'testpassword'
  };

  // First, try to login with valid credentials
  const loginResponse = http.post(
    `${API_BASE_URL}/api/auth/login`,
    JSON.stringify(validCredentials),
    {
      headers: { 'Content-Type': 'application/json' },
      tags: { security_test: 'session_mgmt', method: 'login' },
    }
  );

  if (loginResponse.status === 200) {
    let token;
    try {
      const loginData = JSON.parse(loginResponse.body);
      token = loginData.token;
    } catch (e) {
      console.log('Failed to parse login response');
      return;
    }

    // Test 2: Token Reuse After Logout
    const logoutResponse = http.post(
      `${API_BASE_URL}/api/auth/logout`,
      null,
      {
        headers: { 'Authorization': `Bearer ${token}` },
        tags: { security_test: 'session_mgmt', method: 'logout' },
      }
    );

    // Try to use the token after logout
    const afterLogoutResponse = http.get(
      `${API_BASE_URL}/api/auth/profile`,
      {
        headers: { 'Authorization': `Bearer ${token}` },
        tags: { security_test: 'session_mgmt', method: 'token_reuse' },
      }
    );

    const tokenInvalidated = check(afterLogoutResponse, {
      'token invalidated after logout': (r) => r.status === 401
    });

    if (!tokenInvalidated) {
      vulnerabilityDetected.add(1);
      console.log(`‚ö†Ô∏è Token still valid after logout - session not properly invalidated`);
    } else {
      securityTestsPassed.add(1);
    }
  }

  // Test 3: Concurrent Session Limits
  const credentials = {
    email: 'concurrent@example.com',
    username: 'concurrentuser',
    password: 'testpassword',
    role: 'creator'
  };

  // Register user
  http.post(
    `${API_BASE_URL}/api/auth/register`,
    JSON.stringify(credentials),
    { headers: { 'Content-Type': 'application/json' } }
  );

  // Login multiple times to test concurrent session handling
  const sessions = [];
  for (let i = 0; i < 5; i++) {
    const sessionResponse = http.post(
      `${API_BASE_URL}/api/auth/login`,
      JSON.stringify({ email: credentials.email, password: credentials.password }),
      {
        headers: { 'Content-Type': 'application/json' },
        tags: { security_test: 'session_mgmt', method: 'concurrent_login' },
      }
    );

    if (sessionResponse.status === 200) {
      try {
        const sessionData = JSON.parse(sessionResponse.body);
        sessions.push(sessionData.token);
      } catch (e) {
        // Ignore parse errors
      }
    }
  }

  // Test if all sessions are still valid (potential security issue)
  let validSessions = 0;
  for (const sessionToken of sessions) {
    const profileResponse = http.get(
      `${API_BASE_URL}/api/auth/profile`,
      {
        headers: { 'Authorization': `Bearer ${sessionToken}` },
        tags: { security_test: 'session_mgmt', method: 'check_concurrent' },
      }
    );

    if (profileResponse.status === 200) {
      validSessions++;
    }
  }

  const concurrentSessionsLimited = check(sessions, {
    'concurrent sessions properly limited': () => validSessions <= 3 // Allow max 3 concurrent sessions
  });

  if (!concurrentSessionsLimited) {
    vulnerabilityDetected.add(1);
    console.log(`‚ö†Ô∏è Too many concurrent sessions allowed: ${validSessions}`);
  } else {
    securityTestsPassed.add(1);
  }
}

export function handleSummary(data) {
  return {
    'auth-pentest-results.json': JSON.stringify(data, null, 2),
    stdout: `
üõ°Ô∏è Authentication Security Test Results
=======================================

üîç Security Test Metrics:
- Total Security Tests: ${data.metrics.http_reqs.values.count}
- Vulnerabilities Detected: ${(data.metrics.vulnerabilities_detected?.values.rate * 100 || 0).toFixed(2)}%
- Security Tests Passed: ${(data.metrics.security_tests_passed?.values.rate * 100 || 0).toFixed(2)}%

üéØ Security Assessment:
${(data.metrics.vulnerabilities_detected?.values.rate || 0) < 0.1 ? '‚úÖ SECURE - No critical vulnerabilities detected' : ''}
${(data.metrics.vulnerabilities_detected?.values.rate || 0) >= 0.1 && (data.metrics.vulnerabilities_detected?.values.rate || 0) < 0.3 ? '‚ö†Ô∏è MODERATE RISK - Some vulnerabilities detected' : ''}
${(data.metrics.vulnerabilities_detected?.values.rate || 0) >= 0.3 ? 'üö® HIGH RISK - Multiple vulnerabilities detected' : ''}

üîß Recommendations:
- Review all detected vulnerabilities immediately
- Implement proper input sanitization
- Ensure authentication bypass protections are in place
- Verify session management security
- Consider implementing rate limiting
- Add security headers to all responses

üéØ Threshold Results:
${Object.entries(data.thresholds || {}).map(([key, result]) =>
  `- ${key}: ${result.ok ? '‚úÖ PASS' : '‚ùå FAIL'}`
).join('\n')}
`,
  };
}